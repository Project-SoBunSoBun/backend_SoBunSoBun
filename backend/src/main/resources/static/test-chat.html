<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>채팅 테스트 - 2 클라이언트</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* 페이지 자체 스크롤 제거 */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
        }

        /* 메인 영역: 좌우 2 클라이언트 */
        .container {
            flex: 1 1 auto;
            display: flex;
            gap: 2px;
            height: 100%;
            overflow: hidden; /* 내부에서만 스크롤 나도록 */
        }

        .client-wrapper {
            flex: 1;
            display: flex;
            background: white;
            position: relative;
        }

        /* 채팅방 목록 페이지 */
        .room-list-page {
            position: absolute;
            inset: 0;
            background: white;
            display: flex;
            flex-direction: column;
        }
        .room-list-page.hidden {
            display: none; /* 방에 들어가면 목록은 안 보이게 */
        }

        /* 채팅방 페이지 */
        .chat-page {
            position: absolute;
            inset: 0;
            background: white;
            display: none;
            flex-direction: column;
        }
        .chat-page.active {
            display: flex;
        }

        .page-header {
            padding: 10px 12px;
            background: #3b5998;
            color: white;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 0 0 auto;
        }

        .back-button {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .back-button:hover {
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
        }

        .page-title {
            flex: 1;
        }

        .status {
            padding: 5px 8px;
            font-size: 11px;
            text-align: center;
            background: #fff3cd;
            border-bottom: 1px solid #ffc107;
            flex: 0 0 auto;
        }
        .status.connected {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .room-list-controls {
            padding: 8px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            flex: 0 0 auto;
        }
        .room-list-controls button {
            width: 100%;
            padding: 6px;
            background: #3b5998;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 4px;
        }
        .room-list-controls button:hover {
            background: #2d4373;
        }

        .room-items {
            flex: 1 1 auto;
            overflow-y: auto;
        }

        .room-item {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 13px;
        }
        .room-item:hover {
            background: #f5f5f5;
        }
        .room-item.active {
            background: #e3f2fd;
        }
        .room-item-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 13px;
        }
        .room-item-info {
            font-size: 11px;
            color: #666;
        }

        /* 채팅 메시지 영역 */
        .messages {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 12px;
            background: #ffffff;
        }
        .message {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
        }
        .message.mine {
            flex-direction: row-reverse; /* 내 메시지는 오른쪽 */
        }
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
            flex-shrink: 0;
            overflow: hidden;
        }
        .message-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .message-content {
            max-width: 70%;
            margin: 0 8px;
        }
        .message.mine .message-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .message-sender {
            font-size: 11px;
            color: #666;
            margin-bottom: 3px;
        }
        .message.mine .message-sender {
            display: none;
        }
        .message-bubble {
            padding: 8px 11px;
            border-radius: 16px;
            background: #f0f0f0;
            display: inline-block;
            word-wrap: break-word;
            font-size: 13px;
        }
        .message.mine .message-bubble {
            background: #3b5998;
            color: white;
        }
        .message-time {
            font-size: 10px;
            color: #999;
            margin-top: 3px;
        }

        /* 날짜 구분선 */
        .date-separator {
            display: flex;
            align-items: center;
            margin: 20px 0;
            text-align: center;
        }
        .date-separator::before,
        .date-separator::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid #e0e0e0;
        }
        .date-separator-text {
            padding: 0 16px;
            font-size: 12px;
            color: #666;
            background: #f5f5f5;
            border-radius: 12px;
            padding: 4px 12px;
        }

        /* 입력 영역 */
        .input-area {
            padding: 8px 10px;
            border-top: 1px solid #e0e0e0;
            background: white;
            display: flex;
            gap: 8px;
            flex: 0 0 auto;
        }
        .input-area input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 13px;
        }
        .input-area button {
            padding: 8px 16px;
            background: #3b5998;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }
        .input-area button:hover {
            background: #2d4373;
        }
        .input-area button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* 로그 패널 */
        .log-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            display: none;
            z-index: 900;
        }
        .log-panel.show {
            display: block;
        }
        .toggle-log {
            position: fixed;
            bottom: 8px;
            right: 8px;
            padding: 6px 12px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1000;
            font-size: 11px;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- Client A -->
    <div class="client-wrapper">
        <!-- 채팅방 목록 페이지 -->
        <div class="room-list-page" id="roomListPageA">
            <div class="page-header">
                <div class="page-title">클라이언트 A - 채팅방 목록</div>
            </div>
            <div class="status" id="statusA">토큰을 입력하고 로그인하세요</div>
            <div class="room-list-controls">
                <input id="tokenA" type="text" placeholder="카카오 액세스 토큰" style="width: 100%; margin-bottom: 4px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;" />
                <button onclick="clientA.loginWithToken()">로그인</button>
                <button onclick="clientA.createRoom()">새 채팅방 만들기</button>
            </div>
            <div class="room-items" id="roomListA"></div>
        </div>

        <!-- 채팅방 페이지 -->
        <div class="chat-page" id="chatPageA">
            <div class="page-header">
                <button class="back-button" onclick="clientA.goBack()">←</button>
                <div class="page-title" id="roomNameA">채팅방</div>
            </div>
            <div class="messages" id="messagesA"></div>
            <div class="input-area">
                <input id="inputA" type="text" placeholder="메시지를 입력하세요" disabled />
                <button id="sendBtnA" onclick="clientA.sendMessage()" disabled>전송</button>
            </div>
        </div>
    </div>

    <!-- Client B -->
    <div class="client-wrapper">
        <!-- 채팅방 목록 페이지 -->
        <div class="room-list-page" id="roomListPageB">
            <div class="page-header">
                <div class="page-title">클라이언트 B - 채팅방 목록</div>
            </div>
            <div class="status" id="statusB">토큰을 입력하고 로그인하세요</div>
            <div class="room-list-controls">
                <input id="tokenB" type="text" placeholder="카카오 액세스 토큰" style="width: 100%; margin-bottom: 4px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;" />
                <button onclick="clientB.loginWithToken()">로그인</button>
                <button onclick="clientB.createRoom()">새 채팅방 만들기</button>
            </div>
            <div class="room-items" id="roomListB"></div>
        </div>

        <!-- 채팅방 페이지 -->
        <div class="chat-page" id="chatPageB">
            <div class="page-header">
                <button class="back-button" onclick="clientB.goBack()">←</button>
                <div class="page-title" id="roomNameB">채팅방</div>
            </div>
            <div class="messages" id="messagesB"></div>
            <div class="input-area">
                <input id="inputB" type="text" placeholder="메시지를 입력하세요" disabled />
                <button id="sendBtnB" onclick="clientB.sendMessage()" disabled>전송</button>
            </div>
        </div>
    </div>
</div>

<button class="toggle-log" onclick="toggleLog()">로그 표시/숨김</button>
<div class="log-panel" id="logPanel"></div>

<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
<script>
    const API_BASE = 'http://localhost:8080';

    // 로그 함수
    function log(msg) {
        const panel = document.getElementById('logPanel');
        const time = new Date().toLocaleTimeString();
        panel.textContent += `[${time}] ${msg}\n`;
        panel.scrollTop = panel.scrollHeight;
    }

    function toggleLog() {
        document.getElementById('logPanel').classList.toggle('show');
    }

    class ChatClient {
        constructor(id, uiClientId) {
            this.id = id;                    // A / B
            this.uiClientId = uiClientId;    // 'A' / 'B' (좌우 관점)
            this.token = null;
            this.stompClient = null;
            this.currentRoom = null;
            this.currentRoomId = null;
            this.rooms = [];
            this.userInfo = null;
            this.subscription = null;
            this.storageKey = `chat_token_${id}`;
            this.lastMessageDate = null;     // 마지막 메시지 날짜 추적
        }

        // localStorage에서 토큰 로드
        loadTokenFromStorage() {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                this.token = stored;
                log(`${this.id}: localStorage에서 토큰 로드됨`);
                return true;
            }
            return false;
        }

        saveTokenToStorage() {
            if (this.token) {
                localStorage.setItem(this.storageKey, this.token);
                log(`${this.id}: localStorage에 토큰 저장됨`);
            }
        }

        clearTokenFromStorage() {
            localStorage.removeItem(this.storageKey);
            log(`${this.id}: localStorage에서 토큰 삭제됨`);
        }

        setStatus(message, type = 'normal') {
            const status = document.getElementById(`status${this.id}`);
            status.textContent = message;
            status.className = 'status';
            if (type === 'connected') status.classList.add('connected');
            if (type === 'error') status.classList.add('error');
        }

        async loginWithToken() {
            const tokenInput = document.getElementById(`token${this.id}`);
            const kakaoToken = tokenInput.value.trim();

            if (!kakaoToken) {
                alert('카카오 액세스 토큰을 입력하세요');
                return;
            }

            await this.login(kakaoToken);
        }

        async login(kakaoToken) {
            try {
                this.setStatus('로그인 처리 중...');
                log(`${this.id}: 로그인 시작`);

                const res = await fetch(`${API_BASE}/auth/complete-signup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        loginToken: kakaoToken,
                        serviceTermsAgreed: true,
                        privacyPolicyAgreed: true,
                        marketingOptionalAgreed: false
                    })
                });

                if (!res.ok) {
                    const error = await res.text();
                    throw new Error(`로그인 실패: ${error}`);
                }

                const data = await res.json();
                this.token = data.accessToken;
                // Number로 타입을 명확히 지정
                this.myUserId = Number(data.user?.id ?? this.getSenderIdFromToken());
                log(`${this.id}: JWT 발급 완료 - 사용자 ID: ${this.myUserId} (타입: ${typeof this.myUserId})`);

                this.saveTokenToStorage();

                await this.loadRooms();
                await this.connectWebSocket();
                this.setStatus('연결됨', 'connected');
                log(`${this.id}: 로그인 성공`);

            } catch (error) {
                this.setStatus('로그인 실패', 'error');
                log(`${this.id}: 로그인 실패 - ${error}`);
                throw error;
            }
        }

        async autoLogin() {
            if (this.loadTokenFromStorage()) {
                try {
                    // Number로 타입을 명확히 지정
                    this.myUserId = Number(this.getSenderIdFromToken());
                    this.setStatus('자동 로그인 중...');
                    log(`${this.id}: 자동 로그인 - 사용자 ID: ${this.myUserId} (타입: ${typeof this.myUserId})`);
                    await this.loadRooms();
                    await this.connectWebSocket();
                    this.setStatus('연결됨 (자동)', 'connected');
                    log(`${this.id}: 자동 로그인 성공`);
                    return true;
                } catch (error) {
                    this.setStatus('토큰 만료 - 다시 로그인하세요', 'error');
                    log(`${this.id}: 자동 로그인 실패 - ${error}`);
                    this.clearTokenFromStorage();
                    return false;
                }
            }
            return false;
        }

        async loadRooms() {
            if (!this.token) {
                alert('먼저 로그인하세요');
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/api/chat/rooms`, {
                    headers: { 'Authorization': `Bearer ${this.token}` }
                });

                if (!res.ok) throw new Error('채팅방 목록 조회 실패');

                this.rooms = await res.json();
                this.renderRoomList();
                log(`${this.id}: 채팅방 ${this.rooms.length}개 로드됨`);
            } catch (error) {
                log(`${this.id}: 채팅방 목록 로드 실패 - ${error}`);
                alert('채팅방 목록을 불러오지 못했습니다');
            }
        }

        renderRoomList() {
            const container = document.getElementById(`roomList${this.id}`);
            container.innerHTML = '';

            if (this.rooms.length === 0) {
                container.innerHTML =
                    '<div style="padding: 16px; text-align: center; color: #999; font-size: 12px;">채팅방이 없습니다</div>';
                return;
            }

            this.rooms.forEach(room => {
                const div = document.createElement('div');
                div.className = 'room-item';
                if (this.currentRoomId === room.roomId) {
                    div.classList.add('active');
                }

                const members = room.chatMembers || [];
                const memberNames = members.map(m => m.nickname).join(', ');

                div.innerHTML = `
                    <div class="room-item-title">${room.title || '제목 없음'}</div>
                    <div class="room-item-info">멤버: ${memberNames}</div>
                `;

                div.onclick = () => this.selectRoom(room);
                container.appendChild(div);
            });
        }

        async selectRoom(room) {
            if (this.subscription) {
                this.subscription.unsubscribe();
                this.subscription = null;
            }

            this.currentRoom = room;
            this.currentRoomId = room.roomId;
            this.renderRoomList();

            document.getElementById(`roomName${this.id}`).textContent = room.title || '제목 없음';
            document.getElementById(`messages${this.id}`).innerHTML = '';

            // 날짜 추적 초기화
            this.lastMessageDate = null;

            document.getElementById(`input${this.id}`).disabled = false;
            document.getElementById(`sendBtn${this.id}`).disabled = false;

            // 채팅 페이지를 먼저 표시
            this.showChatPage();

            // 페이지가 표시된 후 채팅 내역 불러오기
            await this.loadChatHistory(room.roomId);

            if (this.stompClient && this.stompClient.connected) {
                this.subscribeToRoom(room.roomId);
            }

            log(`${this.id}: 채팅방 "${room.title}" 선택됨 (ID: ${room.roomId})`);
        }

        showChatPage() {
            document.getElementById(`roomListPage${this.id}`).classList.add('hidden');
            document.getElementById(`chatPage${this.id}`).classList.add('active');
        }

        goBack() {
            document.getElementById(`roomListPage${this.id}`).classList.remove('hidden');
            document.getElementById(`chatPage${this.id}`).classList.remove('active');

            if (this.subscription) {
                this.subscription.unsubscribe();
                this.subscription = null;
            }

            log(`${this.id}: 채팅방 목록으로 돌아감`);
        }

        async connectWebSocket() {
            return new Promise((resolve, reject) => {
                const socket = new SockJS(`${API_BASE}/ws/connect`);
                this.stompClient = Stomp.over(socket);
                this.stompClient.debug = (msg) => log(`${this.id} WS: ${msg}`);

                this.stompClient.connect(
                    { Authorization: `Bearer ${this.token}` },
                    (frame) => {
                        log(`${this.id}: WebSocket 연결됨`);

                        if (this.currentRoomId) {
                            this.subscribeToRoom(this.currentRoomId);
                        }

                        resolve();
                    },
                    (error) => {
                        log(`${this.id}: WebSocket 연결 실패 - ${error}`);
                        reject(error);
                    }
                );
            });
        }

        async loadChatHistory(roomId, cursorMillis = null, size = 30) {
            if (!this.token) {
                log(`${this.id}: 토큰이 없어 채팅 내역을 불러올 수 없습니다`);
                return;
            }

            try {
                let url = `${API_BASE}/api/chat/rooms/${roomId}/messages?size=${size}`;
                if (cursorMillis) {
                    url += `&cursorMillis=${cursorMillis}`;
                }

                const res = await fetch(url, {
                    headers: { 'Authorization': `Bearer ${this.token}` }
                });

                if (!res.ok) {
                    throw new Error('채팅 내역 조회 실패');
                }

                const data = await res.json();
                log(`${this.id}: 채팅 내역 ${data.messages.length}개 로드됨 (hasNext: ${data.hasNext})`);

                // API는 최신순(DESC)으로 내려주므로 역순으로 정렬하여 오래된 메시지부터 표시
                const messages = data.messages.reverse();

                messages.forEach(msg => {
                    this.displayHistoryMessage(msg);
                });

                // DOM 렌더링 완료 후 스크롤을 최하단으로 이동
                requestAnimationFrame(() => {
                    const container = document.getElementById(`messages${this.id}`);
                    container.scrollTop = container.scrollHeight;
                    log(`${this.id}: 스크롤을 최하단으로 이동 (scrollTop: ${container.scrollTop}, scrollHeight: ${container.scrollHeight})`);
                });

                // 더 많은 메시지가 있으면 스크롤 이벤트 리스너 추가 가능
                if (data.hasNext) {
                    log(`${this.id}: 더 많은 메시지가 있습니다 (nextCursor: ${data.nextCursorMillis})`);
                    // TODO: 스크롤 상단 도달 시 이전 메시지 로드
                }

            } catch (error) {
                log(`${this.id}: 채팅 내역 로드 실패 - ${error}`);
            }
        }

        displayHistoryMessage(data) {
            const container = document.getElementById(`messages${this.id}`);

            // 날짜 구분선 추가
            if (data.sentAt) {
                const messageDate = this.getDateString(data.sentAt);
                if (this.lastMessageDate !== messageDate) {
                    this.addDateSeparator(container, messageDate);
                    this.lastMessageDate = messageDate;
                }
            }

            // 메시지 표시
            const div = document.createElement('div');

            // 내 메시지인지 확인 (타입 변환하여 비교)
            const senderId = Number(data.senderId);
            const myUserId = Number(this.myUserId);
            const isMine = senderId === myUserId;
            log(`${this.id}: displayHistory - senderId: ${senderId} (타입: ${typeof senderId}), myUserId: ${myUserId} (타입: ${typeof myUserId}), isMine: ${isMine}`);

            div.className = isMine ? 'message mine' : 'message';

            // 채팅방 멤버 정보에서 프로필 이미지 가져오기
            let avatarContent = '';
            let senderProfileImage = null;

            if (this.currentRoom && this.currentRoom.chatMembers) {
                const member = this.currentRoom.chatMembers.find(m => m.userId === data.senderId);
                if (member) {
                    senderProfileImage = member.profileImageUrl;
                }
            }

            if (senderProfileImage) {
                avatarContent = `<img src="${senderProfileImage}" alt="${data.senderName || 'User'}" />`;
            } else {
                const initial = (data.senderName || data.senderId || 'U').toString().charAt(0).toUpperCase();
                avatarContent = initial;
            }

            const time = data.sentAt ? new Date(data.sentAt).toLocaleTimeString('ko-KR', {
                hour: '2-digit',
                minute: '2-digit'
            }) : '';

            div.innerHTML = `
                <div class="message-avatar">${avatarContent}</div>
                <div class="message-content">
                    <div class="message-sender">${data.senderName || (data.senderId ? `User ${data.senderId}` : '')}</div>
                    <div class="message-bubble">${this.escapeHtml(data.content || '')}</div>
                    <div class="message-time">${time}</div>
                </div>
            `;

            container.appendChild(div);
        }

        subscribeToRoom(roomId) {
            if (!this.stompClient || !this.stompClient.connected) {
                log(`${this.id}: WebSocket이 연결되지 않음`);
                return;
            }

            this.subscription = this.stompClient.subscribe(
                `/sub/chat/rooms/${roomId}`,
                (message) => {
                    log(`${this.id}: RECV raw: ${message.body}`);

                    let data;
                    try {
                        data = JSON.parse(message.body);
                    } catch (e) {
                        data = { content: message.body };
                    }

                    this.displayMessage(data);
                }
            );

            log(`${this.id}: 채팅방 ${roomId} 구독 시작`);
        }

        // isLocal: 내가 지금 보낸 메시지(로컬 에코)인지 여부
    displayMessage(data) {
        const container = document.getElementById(`messages${this.id}`);

        // 날짜 구분선 추가
        if (data.sentAt) {
            const messageDate = this.getDateString(data.sentAt);
            if (this.lastMessageDate !== messageDate) {
                this.addDateSeparator(container, messageDate);
                this.lastMessageDate = messageDate;
            }
        }

        const div = document.createElement('div');

        // 내 메시지인지 확인 (타입 변환하여 비교)
        const senderId = Number(data.senderId);
        const myUserId = Number(this.myUserId);
        const isMine = senderId === myUserId;
        log(`${this.id}: displayMessage - senderId: ${senderId} (타입: ${typeof senderId}), myUserId: ${myUserId} (타입: ${typeof myUserId}), isMine: ${isMine}`);

        div.className = isMine ? 'message mine' : 'message';

        // 채팅방 멤버 정보에서 프로필 이미지 가져오기
        let avatarContent = '';
        let senderProfileImage = null;

        if (this.currentRoom && this.currentRoom.chatMembers) {
            const member = this.currentRoom.chatMembers.find(m => m.userId === data.senderId);
            if (member) {
                senderProfileImage = member.profileImageUrl;
            }
        }

        if (senderProfileImage) {
            avatarContent = `<img src="${senderProfileImage}" alt="${data.senderName || 'User'}" />`;
        } else {
            const initial = (data.senderName || data.senderId || 'U').toString().charAt(0).toUpperCase();
            avatarContent = initial;
        }

        const time = data.sentAt ? new Date(data.sentAt).toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        }) : '';

        div.innerHTML = `
            <div class="message-avatar">${avatarContent}</div>
            <div class="message-content">
                <div class="message-sender">${data.senderName || (data.senderId ? `User ${data.senderId}` : '')}</div>
                <div class="message-bubble">${this.escapeHtml(data.content || '')}</div>
                <div class="message-time">${time}</div>
            </div>
        `;

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

        sendMessage() {
            if (!this.stompClient || !this.stompClient.connected) {
                alert('WebSocket이 연결되지 않았습니다');
                return;
            }

            if (!this.currentRoomId) {
                alert('채팅방을 먼저 선택하세요');
                return;
            }

            const input = document.getElementById(`input${this.id}`);
            const content = input.value.trim();
            if (!content) return;

            const payload = {
                type: 'TALK',
                content: content
            };

            // 1) 서버로 전송
            this.stompClient.send(
                `/pub/chat/rooms/${this.currentRoomId}/send`,
                {},
                JSON.stringify(payload)
            );

            input.value = '';
            log(`${this.id}: 메시지 전송 - "${content}"`);
        }

        async createRoom() {
            if (!this.token) {
                alert('먼저 로그인하세요');
                return;
            }

            const title = prompt('채팅방 제목을 입력하세요:');
            if (!title) return;

            const memberIdsStr = prompt('초대할 멤버 ID를 쉼표로 구분하여 입력하세요 (예: 1,2,3):');
            if (!memberIdsStr) return;

            const memberIds = memberIdsStr.split(',')
                .map(id => parseInt(id.trim()))
                .filter(id => !isNaN(id));

            try {
                const res = await fetch(`${API_BASE}/api/chat/rooms`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.token}`
                    },
                    body: JSON.stringify({
                        title: title,
                        memberIds: memberIds,
                        type: 'GROUP',
                        postId: null
                    })
                });

                if (!res.ok) {
                    const error = await res.text();
                    throw new Error(error);
                }

                const newRoom = await res.json();
                log(`${this.id}: 채팅방 생성됨 - ${newRoom.title} (ID: ${newRoom.roomId})`);

                await this.loadRooms();
                alert('채팅방이 생성되었습니다!');
            } catch (error) {
                log(`${this.id}: 채팅방 생성 실패 - ${error}`);
                alert('채팅방 생성에 실패했습니다: ' + error.message);
            }
        }

        getSenderIdFromToken() {
            if (!this.token) return null;
            try {
                const base64Url = this.token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                const payload = JSON.parse(jsonPayload);
                return payload.userId || payload.sub || payload.id;
            } catch (e) {
                return null;
            }
        }

        getDateString(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            // 날짜를 YYYY-MM-DD 형식으로 비교
            const dateStr = date.toISOString().split('T')[0];
            const todayStr = today.toISOString().split('T')[0];
            const yesterdayStr = yesterday.toISOString().split('T')[0];

            if (dateStr === todayStr) {
                return '오늘';
            } else if (dateStr === yesterdayStr) {
                return '어제';
            } else {
                // YYYY년 MM월 DD일 형식
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return `${year}년 ${month}월 ${day}일`;
            }
        }

        addDateSeparator(container, dateText) {
            const separator = document.createElement('div');
            separator.className = 'date-separator';
            separator.innerHTML = `<div class="date-separator-text">${dateText}</div>`;
            container.appendChild(separator);
        }

        escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
    }

    // 클라이언트 인스턴스 생성
    const clientA = new ChatClient('A', 'A'); // 왼쪽 화면
    const clientB = new ChatClient('B', 'B'); // 오른쪽 화면

    // 엔터키 이벤트 리스너
    document.getElementById('inputA').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') clientA.sendMessage();
    });
    document.getElementById('inputB').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') clientB.sendMessage();
    });

    document.getElementById('tokenA').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') clientA.loginWithToken();
    });
    document.getElementById('tokenB').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') clientB.loginWithToken();
    });

    window.addEventListener('load', async () => {
        log('채팅 테스트 페이지 로드됨');
        log('자동 로그인 시도 중...');

        await clientA.autoLogin();
        await clientB.autoLogin();
    });
</script>

</body>
</html>